var assert=require("assert-plus");var crypto=require("crypto");var http=require("http");var util=require("util");var sshpk=require("sshpk");var jsprim=require("jsprim");var utils=require("./utils");var sprintf=require("util").format;var HASH_ALGOS=utils.HASH_ALGOS;var PK_ALGOS=utils.PK_ALGOS;var InvalidAlgorithmError=utils.InvalidAlgorithmError;var HttpSignatureError=utils.HttpSignatureError;var validateAlgorithm=utils.validateAlgorithm;var AUTHZ_FMT='Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';function MissingHeaderError(a){HttpSignatureError.call(this,a,MissingHeaderError)}util.inherits(MissingHeaderError,HttpSignatureError);function StrictParsingError(a){HttpSignatureError.call(this,a,StrictParsingError)}util.inherits(StrictParsingError,HttpSignatureError);function RequestSigner(a){assert.object(a,"options");var c=[];if(a.algorithm!==undefined){assert.string(a.algorithm,"options.algorithm");c=validateAlgorithm(a.algorithm)}this.rs_alg=c;if(a.sign!==undefined){assert.func(a.sign,"options.sign");this.rs_signFunc=a.sign}else{if(c[0]==="hmac"&&a.key!==undefined){assert.string(a.keyId,"options.keyId");this.rs_keyId=a.keyId;if(typeof(a.key)!=="string"&&!Buffer.isBuffer(a.key)){throw (new TypeError("options.key for HMAC must be a string or Buffer"))}this.rs_signer=crypto.createHmac(c[1].toUpperCase(),a.key);this.rs_signer.sign=function(){var d=this.digest("base64");return({hashAlgorithm:c[1],toString:function(){return(d)}})}}else{if(a.key!==undefined){var b=a.key;if(typeof(b)==="string"||Buffer.isBuffer(b)){b=sshpk.parsePrivateKey(b)}assert.ok(sshpk.PrivateKey.isPrivateKey(b,[1,2]),"options.key must be a sshpk.PrivateKey");this.rs_key=b;assert.string(a.keyId,"options.keyId");this.rs_keyId=a.keyId;if(!PK_ALGOS[b.type]){throw (new InvalidAlgorithmError(b.type.toUpperCase()+" type keys are not supported"))}if(c[0]!==undefined&&b.type!==c[0]){throw (new InvalidAlgorithmError("options.key must be a "+c[0].toUpperCase()+" key, was given a "+b.type.toUpperCase()+" key instead"))}this.rs_signer=b.createSign(c[1])}else{throw (new TypeError("options.sign (func) or options.key is required"))}}}this.rs_headers=[];this.rs_lines=[]}RequestSigner.prototype.writeHeader=function(c,b){assert.string(c,"header");c=c.toLowerCase();assert.string(b,"value");this.rs_headers.push(c);if(this.rs_signFunc){this.rs_lines.push(c+": "+b)}else{var a=c+": "+b;if(this.rs_headers.length>0){a="\n"+a}this.rs_signer.update(a)}return(b)};RequestSigner.prototype.writeDateHeader=function(){return(this.writeHeader("date",jsprim.rfc1123(new Date())))};RequestSigner.prototype.writeTarget=function(b,a){assert.string(b,"method");assert.string(a,"path");b=b.toLowerCase();this.writeHeader("(request-target)",b+" "+a)};RequestSigner.prototype.sign=function(a){assert.func(a,"callback");if(this.rs_headers.length<1){throw (new Error("At least one header must be signed"))}var i,f;if(this.rs_signFunc){var g=this.rs_lines.join("\n");var c=this;this.rs_signFunc(g,function(j,l){if(j){a(j);return}try{assert.object(l,"signature");assert.string(l.keyId,"signature.keyId");assert.string(l.algorithm,"signature.algorithm");assert.string(l.signature,"signature.signature");i=validateAlgorithm(l.algorithm);f=sprintf(AUTHZ_FMT,l.keyId,l.algorithm,c.rs_headers.join(" "),l.signature)}catch(k){a(k);return}a(null,f)})}else{try{var d=this.rs_signer.sign()}catch(h){a(h);return}i=(this.rs_alg[0]||this.rs_key.type)+"-"+d.hashAlgorithm;var b=d.toString();f=sprintf(AUTHZ_FMT,this.rs_keyId,i,this.rs_headers.join(" "),b);a(null,f)}};module.exports={isSigner:function(a){if(typeof(a)==="object"&&a instanceof RequestSigner){return(true)}return(false)},createSigner:function createSigner(a){return(new RequestSigner(a))},signRequest:function signRequest(e,o){assert.object(e,"request");assert.object(o,"options");assert.optionalString(o.algorithm,"options.algorithm");assert.string(o.keyId,"options.keyId");assert.optionalArrayOfString(o.headers,"options.headers");assert.optionalString(o.httpVersion,"options.httpVersion");if(!e.getHeader("Date")){e.setHeader("Date",jsprim.rfc1123(new Date()))}if(!o.headers){o.headers=["date"]}if(!o.httpVersion){o.httpVersion="1.1"}var b=[];if(o.algorithm){o.algorithm=o.algorithm.toLowerCase();b=validateAlgorithm(o.algorithm)}var f;var k="";for(f=0;f<o.headers.length;f++){if(typeof(o.headers[f])!=="string"){throw new TypeError("options.headers must be an array of Strings")}var g=o.headers[f].toLowerCase();if(g==="request-line"){if(!o.strict){k+=e.method+" "+e.path+" HTTP/"+o.httpVersion}else{throw (new StrictParsingError("request-line is not a valid header with strict parsing enabled."))}}else{if(g==="(request-target)"){k+="(request-target): "+e.method.toLowerCase()+" "+e.path}else{var m=e.getHeader(g);if(m===undefined||m===""){throw new MissingHeaderError(g+" was not in the request")}k+=g+": "+m}}if((f+1)<o.headers.length){k+="\n"}}if(e.hasOwnProperty("_stringToSign")){e._stringToSign=k}var d;if(b[0]==="hmac"){if(typeof(o.key)!=="string"&&!Buffer.isBuffer(o.key)){throw (new TypeError("options.key must be a string or Buffer"))}var j=crypto.createHmac(b[1].toUpperCase(),o.key);j.update(k);d=j.digest("base64")}else{var n=o.key;if(typeof(n)==="string"||Buffer.isBuffer(n)){n=sshpk.parsePrivateKey(o.key)}assert.ok(sshpk.PrivateKey.isPrivateKey(n,[1,2]),"options.key must be a sshpk.PrivateKey");if(!PK_ALGOS[n.type]){throw (new InvalidAlgorithmError(n.type.toUpperCase()+" type keys are not supported"))}if(b[0]!==undefined&&n.type!==b[0]){throw (new InvalidAlgorithmError("options.key must be a "+b[0].toUpperCase()+" key, was given a "+n.type.toUpperCase()+" key instead"))}var c=n.createSign(b[1]);c.update(k);var l=c.sign();if(!HASH_ALGOS[l.hashAlgorithm]){throw (new InvalidAlgorithmError(l.hashAlgorithm.toUpperCase()+" is not a supported hash algorithm"))}o.algorithm=n.type+"-"+l.hashAlgorithm;d=l.toString();assert.notStrictEqual(d,"","empty signature produced")}var a=o.authorizationHeaderName||"Authorization";e.setHeader(a,sprintf(AUTHZ_FMT,o.keyId,o.algorithm,o.headers.join(" "),d));return true}};