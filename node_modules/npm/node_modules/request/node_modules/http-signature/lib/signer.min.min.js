var assert=require("assert-plus");var crypto=require("crypto");var http=require("http");var util=require("util");var sshpk=require("sshpk");var jsprim=require("jsprim");var utils=require("./utils");var sprintf=require("util").format;var HASH_ALGOS=utils.HASH_ALGOS;var PK_ALGOS=utils.PK_ALGOS;var InvalidAlgorithmError=utils.InvalidAlgorithmError;var HttpSignatureError=utils.HttpSignatureError;var validateAlgorithm=utils.validateAlgorithm;var AUTHZ_FMT='Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';function MissingHeaderError(b){HttpSignatureError.call(this,b,MissingHeaderError)}util.inherits(MissingHeaderError,HttpSignatureError);function StrictParsingError(b){HttpSignatureError.call(this,b,StrictParsingError)}util.inherits(StrictParsingError,HttpSignatureError);function RequestSigner(e){assert.object(e,"options");var f=[];if(e.algorithm!==undefined){assert.string(e.algorithm,"options.algorithm");f=validateAlgorithm(e.algorithm)}this.rs_alg=f;if(e.sign!==undefined){assert.func(e.sign,"options.sign");this.rs_signFunc=e.sign}else{if(f[0]==="hmac"&&e.key!==undefined){assert.string(e.keyId,"options.keyId");this.rs_keyId=e.keyId;if(typeof(e.key)!=="string"&&!Buffer.isBuffer(e.key)){throw (new TypeError("options.key for HMAC must be a string or Buffer"))}this.rs_signer=crypto.createHmac(f[1].toUpperCase(),e.key);this.rs_signer.sign=function(){var a=this.digest("base64");return({hashAlgorithm:f[1],toString:function(){return(a)}})}}else{if(e.key!==undefined){var d=e.key;if(typeof(d)==="string"||Buffer.isBuffer(d)){d=sshpk.parsePrivateKey(d)}assert.ok(sshpk.PrivateKey.isPrivateKey(d,[1,2]),"options.key must be a sshpk.PrivateKey");this.rs_key=d;assert.string(e.keyId,"options.keyId");this.rs_keyId=e.keyId;if(!PK_ALGOS[d.type]){throw (new InvalidAlgorithmError(d.type.toUpperCase()+" type keys are not supported"))}if(f[0]!==undefined&&d.type!==f[0]){throw (new InvalidAlgorithmError("options.key must be a "+f[0].toUpperCase()+" key, was given a "+d.type.toUpperCase()+" key instead"))}this.rs_signer=d.createSign(f[1])}else{throw (new TypeError("options.sign (func) or options.key is required"))}}}this.rs_headers=[];this.rs_lines=[]}RequestSigner.prototype.writeHeader=function(f,d){assert.string(f,"header");f=f.toLowerCase();assert.string(d,"value");this.rs_headers.push(f);if(this.rs_signFunc){this.rs_lines.push(f+": "+d)}else{var e=f+": "+d;if(this.rs_headers.length>0){e="\n"+e}this.rs_signer.update(e)}return(d)};RequestSigner.prototype.writeDateHeader=function(){return(this.writeHeader("date",jsprim.rfc1123(new Date())))};RequestSigner.prototype.writeTarget=function(c,d){assert.string(c,"method");assert.string(d,"path");c=c.toLowerCase();this.writeHeader("(request-target)",c+" "+d)};RequestSigner.prototype.sign=function(j){assert.func(j,"callback");if(this.rs_headers.length<1){throw (new Error("At least one header must be signed"))}var k,n;if(this.rs_signFunc){var m=this.rs_lines.join("\n");var p=this;this.rs_signFunc(m,function(c,a){if(c){j(c);return}try{assert.object(a,"signature");assert.string(a.keyId,"signature.keyId");assert.string(a.algorithm,"signature.algorithm");assert.string(a.signature,"signature.signature");k=validateAlgorithm(a.algorithm);n=sprintf(AUTHZ_FMT,a.keyId,a.algorithm,p.rs_headers.join(" "),a.signature)}catch(b){j(b);return}j(null,n)})}else{try{var o=this.rs_signer.sign()}catch(l){j(l);return}k=(this.rs_alg[0]||this.rs_key.type)+"-"+o.hashAlgorithm;var e=o.toString();n=sprintf(AUTHZ_FMT,this.rs_keyId,k,this.rs_headers.join(" "),e);j(null,n)}};module.exports={isSigner:function(b){if(typeof(b)==="object"&&b instanceof RequestSigner){return(true)}return(false)},createSigner:function createSigner(b){return(new RequestSigner(b))},signRequest:function signRequest(v,h){assert.object(v,"request");assert.object(h,"options");assert.optionalString(h.algorithm,"options.algorithm");assert.string(h.keyId,"options.keyId");assert.optionalArrayOfString(h.headers,"options.headers");assert.optionalString(h.httpVersion,"options.httpVersion");if(!v.getHeader("Date")){v.setHeader("Date",jsprim.rfc1123(new Date()))}if(!h.headers){h.headers=["date"]}if(!h.httpVersion){h.httpVersion="1.1"}var y=[];if(h.algorithm){h.algorithm=h.algorithm.toLowerCase();y=validateAlgorithm(h.algorithm)}var u;var r="";for(u=0;u<h.headers.length;u++){if(typeof(h.headers[u])!=="string"){throw new TypeError("options.headers must be an array of Strings")}var t=h.headers[u].toLowerCase();if(t==="request-line"){if(!h.strict){r+=v.method+" "+v.path+" HTTP/"+h.httpVersion}else{throw (new StrictParsingError("request-line is not a valid header with strict parsing enabled."))}}else{if(t==="(request-target)"){r+="(request-target): "+v.method.toLowerCase()+" "+v.path}else{var p=v.getHeader(t);if(p===undefined||p===""){throw new MissingHeaderError(t+" was not in the request")}r+=t+": "+p}}if((u+1)<h.headers.length){r+="\n"}}if(v.hasOwnProperty("_stringToSign")){v._stringToSign=r}var w;if(y[0]==="hmac"){if(typeof(h.key)!=="string"&&!Buffer.isBuffer(h.key)){throw (new TypeError("options.key must be a string or Buffer"))}var s=crypto.createHmac(y[1].toUpperCase(),h.key);s.update(r);w=s.digest("base64")}else{var i=h.key;if(typeof(i)==="string"||Buffer.isBuffer(i)){i=sshpk.parsePrivateKey(h.key)}assert.ok(sshpk.PrivateKey.isPrivateKey(i,[1,2]),"options.key must be a sshpk.PrivateKey");if(!PK_ALGOS[i.type]){throw (new InvalidAlgorithmError(i.type.toUpperCase()+" type keys are not supported"))}if(y[0]!==undefined&&i.type!==y[0]){throw (new InvalidAlgorithmError("options.key must be a "+y[0].toUpperCase()+" key, was given a "+i.type.toUpperCase()+" key instead"))}var x=i.createSign(y[1]);x.update(r);var q=x.sign();if(!HASH_ALGOS[q.hashAlgorithm]){throw (new InvalidAlgorithmError(q.hashAlgorithm.toUpperCase()+" is not a supported hash algorithm"))}h.algorithm=i.type+"-"+q.hashAlgorithm;w=q.toString();assert.notStrictEqual(w,"","empty signature produced")}var z=h.authorizationHeaderName||"Authorization";v.setHeader(z,sprintf(AUTHZ_FMT,h.keyId,h.algorithm,h.headers.join(" "),w));return true}};