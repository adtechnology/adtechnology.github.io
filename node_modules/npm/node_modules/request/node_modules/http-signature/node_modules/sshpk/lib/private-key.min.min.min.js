module.exports=PrivateKey;var assert=require("assert-plus");var algs=require("./algs");var crypto=require("crypto");var Fingerprint=require("./fingerprint");var Signature=require("./signature");var errs=require("./errors");var util=require("util");var utils=require("./utils");var dhe=require("./dhe");var generateECDSA=dhe.generateECDSA;var generateED25519=dhe.generateED25519;var edCompat;var nacl;try{edCompat=require("./ed-compat")}catch(e){}var Key=require("./key");var InvalidAlgorithmError=errs.InvalidAlgorithmError;var KeyParseError=errs.KeyParseError;var KeyEncryptedError=errs.KeyEncryptedError;var formats={};formats.auto=require("./formats/auto");formats.pem=require("./formats/pem");formats.pkcs1=require("./formats/pkcs1");formats.pkcs8=require("./formats/pkcs8");formats.rfc4253=require("./formats/rfc4253");formats["ssh-private"]=require("./formats/ssh-private");formats.openssh=formats["ssh-private"];formats.ssh=formats["ssh-private"];formats.dnssec=require("./formats/dnssec");function PrivateKey(a){assert.object(a,"options");Key.call(this,a);this._pubCache=undefined}util.inherits(PrivateKey,Key);PrivateKey.formats=formats;PrivateKey.prototype.toBuffer=function(b,a){if(b===undefined){b="pkcs1"}assert.string(b,"format");assert.object(formats[b],"formats[format]");assert.optionalObject(a,"options");return(formats[b].write(this,a))};PrivateKey.prototype.hash=function(a){return(this.toPublic().hash(a))};PrivateKey.prototype.toPublic=function(){if(this._pubCache){return(this._pubCache)}var b=algs.info[this.type];var a=[];for(var c=0;c<b.parts.length;++c){var d=b.parts[c];a.push(this.part[d])}this._pubCache=new Key({type:this.type,source:this,parts:a});if(this.comment){this._pubCache.comment=this.comment}return(this._pubCache)};PrivateKey.prototype.derive=function(d){assert.string(d,"type");var c,a,b;if(this.type==="ed25519"&&d==="curve25519"){if(nacl===undefined){nacl=require("tweetnacl")}c=this.part.k.data;if(c[0]===0){c=c.slice(1)}b=nacl.box.keyPair.fromSecretKey(new Uint8Array(c));a=new Buffer(b.publicKey);return(new PrivateKey({type:"curve25519",parts:[{name:"A",data:utils.mpNormalize(a)},{name:"k",data:utils.mpNormalize(c)}]}))}else{if(this.type==="curve25519"&&d==="ed25519"){if(nacl===undefined){nacl=require("tweetnacl")}c=this.part.k.data;if(c[0]===0){c=c.slice(1)}b=nacl.sign.keyPair.fromSeed(new Uint8Array(c));a=new Buffer(b.publicKey);return(new PrivateKey({type:"ed25519",parts:[{name:"A",data:utils.mpNormalize(a)},{name:"k",data:utils.mpNormalize(c)}]}))}}throw (new Error("Key derivation not supported from "+this.type+" to "+d))};PrivateKey.prototype.createVerify=function(a){return(this.toPublic().createVerify(a))};PrivateKey.prototype.createSign=function(j){if(j===undefined){j=this.defaultHashAlgorithm()}assert.string(j,"hash algorithm");if(this.type==="ed25519"&&edCompat!==undefined){return(new edCompat.Signer(this,j))}if(this.type==="curve25519"){throw (new Error("Curve25519 keys are not suitable for signing or verification"))}var h,i,c;try{i=j.toUpperCase();h=crypto.createSign(i)}catch(d){c=d}if(h===undefined||(c instanceof Error&&c.message.match(/Unknown message digest/))){i="RSA-";i+=j.toUpperCase();h=crypto.createSign(i)}assert.ok(h,"failed to create verifier");var b=h.sign.bind(h);var g=this.toBuffer("pkcs1");var f=this.type;var a=this.curve;h.sign=function(){var k=b(g);if(typeof(k)==="string"){k=new Buffer(k,"binary")}k=Signature.parse(k,f,"asn1");k.hashAlgorithm=j;k.curve=a;return(k)};return(h)};PrivateKey.parse=function(a,c,f){if(typeof(a)!=="string"){assert.buffer(a,"data")}if(c===undefined){c="auto"}assert.string(c,"format");if(typeof(f)==="string"){f={filename:f}}assert.optionalObject(f,"options");if(f===undefined){f={}}assert.optionalString(f.filename,"options.filename");if(f.filename===undefined){f.filename="(unnamed)"}assert.object(formats[c],"formats[format]");try{var d=formats[c].read(a,f);assert.ok(d instanceof PrivateKey,"key is not a private key");if(!d.comment){d.comment=f.filename}return(d)}catch(b){if(b.name==="KeyEncryptedError"){throw (b)}throw (new KeyParseError(f.filename,c,b))}};PrivateKey.isPrivateKey=function(b,a){return(utils.isCompatible(b,PrivateKey,a))};PrivateKey.generate=function(b,a){if(a===undefined){a={}}assert.object(a,"options");switch(b){case"ecdsa":if(a.curve===undefined){a.curve="nistp256"}assert.string(a.curve,"options.curve");return(generateECDSA(a.curve));case"ed25519":return(generateED25519());default:throw (new Error('Key generation not supported with key type "'+b+'"'))}};PrivateKey.prototype._sshpkApiVersion=[1,5];PrivateKey._oldVersionDetect=function(a){assert.func(a.toPublic);assert.func(a.createSign);if(a.derive){return([1,3])}if(a.defaultHashAlgorithm){return([1,2])}if(a.formats.auto){return([1,1])}return([1,0])};