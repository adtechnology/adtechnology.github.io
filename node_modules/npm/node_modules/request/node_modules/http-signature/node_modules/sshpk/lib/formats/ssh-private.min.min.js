module.exports={read:read,readSSHPrivate:readSSHPrivate,write:write};var assert=require("assert-plus");var asn1=require("asn1");var algs=require("../algs");var utils=require("../utils");var crypto=require("crypto");var Key=require("../key");var PrivateKey=require("../private-key");var pem=require("./pem");var rfc4253=require("./rfc4253");var SSHBuffer=require("../ssh-buffer");var errors=require("../errors");var bcrypt;function read(c,d){return(pem.read(c,d))}var MAGIC="openssh-key-v1";function readSSHPrivate(V,D,W){D=new SSHBuffer({buffer:D});var Q=D.readCString();assert.strictEqual(Q,MAGIC,"bad magic string");var ab=D.readString();var Z=D.readString();var ad=D.readBuffer();var K=D.readInt();if(K!==1){throw (new Error("OpenSSH-format key file contains multiple keys: this is unsupported."))}var E=D.readBuffer();if(V==="public"){assert.ok(D.atEnd(),"excess bytes left after key");return(rfc4253.read(E))}var I=D.readBuffer();assert.ok(D.atEnd(),"excess bytes left after key");var R=new SSHBuffer({buffer:ad});switch(Z){case"none":if(ab!=="none"){throw (new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"'))}break;case"bcrypt":var Y=R.readBuffer();var O=R.readInt();var X=utils.opensshCipherInfo(ab);if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}if(typeof(W.passphrase)==="string"){W.passphrase=new Buffer(W.passphrase,"utf-8")}if(!Buffer.isBuffer(W.passphrase)){throw (new errors.KeyEncryptedError(W.filename,"OpenSSH"))}var ac=new Uint8Array(W.passphrase);var M=new Uint8Array(Y);var F=new Uint8Array(X.keySize+X.blockSize);var L=bcrypt.pbkdf(ac,ac.length,M,M.length,F,F.length,O);if(L!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}F=new Buffer(F);var G=F.slice(0,X.keySize);var U=F.slice(X.keySize,X.keySize+X.blockSize);var P=crypto.createDecipheriv(X.opensslName,G,U);P.setAutoPadding(false);var J,H=[];P.once("error",function(a){if(a.toString().indexOf("bad decrypt")!==-1){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}throw (a)});P.write(I);P.end();while((J=P.read())!==null){H.push(J)}I=Buffer.concat(H);break;default:throw (new Error('OpenSSH-format key uses unknown KDF "'+Z+'"'))}D=new SSHBuffer({buffer:I});var S=D.readInt();var T=D.readInt();if(S!==T){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}var C={};var N=rfc4253.readInternal(C,"private",D.remainder());D.skip(C.consumed);var aa=D.readString();N.comment=aa;return(N)}function write(J,ac){var T;if(PrivateKey.isPrivateKey(J)){T=J.toPublic()}else{T=J}var ag="none";var af="none";var U=new Buffer(0);var ad={blockSize:8};var R;if(ac!==undefined){R=ac.passphrase;if(typeof(R)==="string"){R=new Buffer(R,"utf-8")}if(R!==undefined){assert.buffer(R,"options.passphrase");assert.optionalString(ac.cipher,"options.cipher");ag=ac.cipher;if(ag===undefined){ag="aes128-ctr"}ad=utils.opensshCipherInfo(ag);af="bcrypt"}}var aa;if(PrivateKey.isPrivateKey(J)){aa=new SSHBuffer({});var V=crypto.randomBytes(4).readUInt32BE(0);aa.writeInt(V);aa.writeInt(V);aa.write(J.toBuffer("rfc4253"));aa.writeString(J.comment||"");var L=1;while(aa._offset%ad.blockSize!==0){aa.writeChar(L++)}aa=aa.toBuffer()}switch(af){case"none":break;case"bcrypt":var ae=crypto.randomBytes(16);var Y=16;var P=new SSHBuffer({});P.writeBuffer(ae);P.writeInt(Y);U=P.toBuffer();if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}var ah=new Uint8Array(R);var X=new Uint8Array(ae);var n=new Uint8Array(ad.keySize+ad.blockSize);var K=bcrypt.pbkdf(ah,ah.length,X,X.length,n,n.length,Y);if(K!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}n=new Buffer(n);var I=n.slice(0,ad.keySize);var ab=n.slice(ad.keySize,ad.keySize+ad.blockSize);var Z=crypto.createCipheriv(ad.opensslName,I,ab);Z.setAutoPadding(false);var W,S=[];Z.once("error",function(a){throw (a)});Z.write(aa);Z.end();while((W=Z.read())!==null){S.push(W)}aa=Buffer.concat(S);break;default:throw (new Error("Unsupported kdf "+af))}var O=new SSHBuffer({});O.writeCString(MAGIC);O.writeString(ag);O.writeString(af);O.writeBuffer(U);O.writeInt(1);O.writeBuffer(T.toBuffer("rfc4253"));if(aa){O.writeBuffer(aa)}O=O.toBuffer();var o;if(PrivateKey.isPrivateKey(J)){o="OPENSSH PRIVATE KEY"}else{o="OPENSSH PUBLIC KEY"}var N=O.toString("base64");var i=N.length+(N.length/70)+18+16+o.length*2+10;O=new Buffer(i);var M=0;M+=O.write("-----BEGIN "+o+"-----\n",M);for(var H=0;H<N.length;){var Q=H+70;if(Q>N.length){Q=N.length}M+=O.write(N.slice(H,Q),M);O[M++]=10;H=Q}M+=O.write("-----END "+o+"-----\n",M);return(O.slice(0,M))};