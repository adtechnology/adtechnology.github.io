module.exports=PrivateKey;var assert=require("assert-plus");var algs=require("./algs");var crypto=require("crypto");var Fingerprint=require("./fingerprint");var Signature=require("./signature");var errs=require("./errors");var util=require("util");var utils=require("./utils");var dhe=require("./dhe");var generateECDSA=dhe.generateECDSA;var generateED25519=dhe.generateED25519;var edCompat;var nacl;try{edCompat=require("./ed-compat")}catch(e){}var Key=require("./key");var InvalidAlgorithmError=errs.InvalidAlgorithmError;var KeyParseError=errs.KeyParseError;var KeyEncryptedError=errs.KeyEncryptedError;var formats={};formats.auto=require("./formats/auto");formats.pem=require("./formats/pem");formats.pkcs1=require("./formats/pkcs1");formats.pkcs8=require("./formats/pkcs8");formats.rfc4253=require("./formats/rfc4253");formats["ssh-private"]=require("./formats/ssh-private");formats.openssh=formats["ssh-private"];formats.ssh=formats["ssh-private"];formats.dnssec=require("./formats/dnssec");function PrivateKey(b){assert.object(b,"options");Key.call(this,b);this._pubCache=undefined}util.inherits(PrivateKey,Key);PrivateKey.formats=formats;PrivateKey.prototype.toBuffer=function(c,d){if(c===undefined){c="pkcs1"}assert.string(c,"format");assert.object(formats[c],"formats[format]");assert.optionalObject(d,"options");return(formats[c].write(this,d))};PrivateKey.prototype.hash=function(b){return(this.toPublic().hash(b))};PrivateKey.prototype.toPublic=function(){if(this._pubCache){return(this._pubCache)}var f=algs.info[this.type];var g=[];for(var i=0;i<f.parts.length;++i){var h=f.parts[i];g.push(this.part[h])}this._pubCache=new Key({type:this.type,source:this,parts:g});if(this.comment){this._pubCache.comment=this.comment}return(this._pubCache)};PrivateKey.prototype.derive=function(h){assert.string(h,"type");var i,g,f;if(this.type==="ed25519"&&h==="curve25519"){if(nacl===undefined){nacl=require("tweetnacl")}i=this.part.k.data;if(i[0]===0){i=i.slice(1)}f=nacl.box.keyPair.fromSecretKey(new Uint8Array(i));g=new Buffer(f.publicKey);return(new PrivateKey({type:"curve25519",parts:[{name:"A",data:utils.mpNormalize(g)},{name:"k",data:utils.mpNormalize(i)}]}))}else{if(this.type==="curve25519"&&h==="ed25519"){if(nacl===undefined){nacl=require("tweetnacl")}i=this.part.k.data;if(i[0]===0){i=i.slice(1)}f=nacl.sign.keyPair.fromSeed(new Uint8Array(i));g=new Buffer(f.publicKey);return(new PrivateKey({type:"ed25519",parts:[{name:"A",data:utils.mpNormalize(g)},{name:"k",data:utils.mpNormalize(i)}]}))}}throw (new Error("Key derivation not supported from "+this.type+" to "+h))};PrivateKey.prototype.createVerify=function(b){return(this.toPublic().createVerify(b))};PrivateKey.prototype.createSign=function(k){if(k===undefined){k=this.defaultHashAlgorithm()}assert.string(k,"hash algorithm");if(this.type==="ed25519"&&edCompat!==undefined){return(new edCompat.Signer(this,k))}if(this.type==="curve25519"){throw (new Error("Curve25519 keys are not suitable for signing or verification"))}var m,l,q;try{l=k.toUpperCase();m=crypto.createSign(l)}catch(p){q=p}if(m===undefined||(q instanceof Error&&q.message.match(/Unknown message digest/))){l="RSA-";l+=k.toUpperCase();m=crypto.createSign(l)}assert.ok(m,"failed to create verifier");var r=m.sign.bind(m);var n=this.toBuffer("pkcs1");var o=this.type;var s=this.curve;m.sign=function(){var a=r(n);if(typeof(a)==="string"){a=new Buffer(a,"binary")}a=Signature.parse(a,o,"asn1");a.hashAlgorithm=k;a.curve=s;return(a)};return(m)};PrivateKey.parse=function(h,k,i){if(typeof(h)!=="string"){assert.buffer(h,"data")}if(k===undefined){k="auto"}assert.string(k,"format");if(typeof(i)==="string"){i={filename:i}}assert.optionalObject(i,"options");if(i===undefined){i={}}assert.optionalString(i.filename,"options.filename");if(i.filename===undefined){i.filename="(unnamed)"}assert.object(formats[k],"formats[format]");try{var j=formats[k].read(h,i);assert.ok(j instanceof PrivateKey,"key is not a private key");if(!j.comment){j.comment=i.filename}return(j)}catch(g){if(g.name==="KeyEncryptedError"){throw (g)}throw (new KeyParseError(i.filename,k,g))}};PrivateKey.isPrivateKey=function(c,d){return(utils.isCompatible(c,PrivateKey,d))};PrivateKey.generate=function(c,d){if(d===undefined){d={}}assert.object(d,"options");switch(c){case"ecdsa":if(d.curve===undefined){d.curve="nistp256"}assert.string(d.curve,"options.curve");return(generateECDSA(d.curve));case"ed25519":return(generateED25519());default:throw (new Error('Key generation not supported with key type "'+c+'"'))}};PrivateKey.prototype._sshpkApiVersion=[1,5];PrivateKey._oldVersionDetect=function(b){assert.func(b.toPublic);assert.func(b.createSign);if(b.derive){return([1,3])}if(b.defaultHashAlgorithm){return([1,2])}if(b.formats.auto){return([1,1])}return([1,0])};