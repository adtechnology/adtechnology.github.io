module.exports=PrivateKey;var assert=require("assert-plus");var algs=require("./algs");var crypto=require("crypto");var Fingerprint=require("./fingerprint");var Signature=require("./signature");var errs=require("./errors");var util=require("util");var utils=require("./utils");var dhe=require("./dhe");var generateECDSA=dhe.generateECDSA;var generateED25519=dhe.generateED25519;var edCompat;var nacl;try{edCompat=require("./ed-compat")}catch(e){}var Key=require("./key");var InvalidAlgorithmError=errs.InvalidAlgorithmError;var KeyParseError=errs.KeyParseError;var KeyEncryptedError=errs.KeyEncryptedError;var formats={};formats.auto=require("./formats/auto");formats.pem=require("./formats/pem");formats.pkcs1=require("./formats/pkcs1");formats.pkcs8=require("./formats/pkcs8");formats.rfc4253=require("./formats/rfc4253");formats["ssh-private"]=require("./formats/ssh-private");formats.openssh=formats["ssh-private"];formats.ssh=formats["ssh-private"];formats.dnssec=require("./formats/dnssec");function PrivateKey(a){assert.object(a,"options");Key.call(this,a);this._pubCache=undefined}util.inherits(PrivateKey,Key);PrivateKey.formats=formats;PrivateKey.prototype.toBuffer=function(b,a){if(b===undefined){b="pkcs1"}assert.string(b,"format");assert.object(formats[b],"formats[format]");assert.optionalObject(a,"options");return(formats[b].write(this,a))};PrivateKey.prototype.hash=function(a){return(this.toPublic().hash(a))};PrivateKey.prototype.toPublic=function(){if(this._pubCache){return(this._pubCache)}var d=algs.info[this.type];var c=[];for(var a=0;a<d.parts.length;++a){var b=d.parts[a];c.push(this.part[b])}this._pubCache=new Key({type:this.type,source:this,parts:c});if(this.comment){this._pubCache.comment=this.comment}return(this._pubCache)};PrivateKey.prototype.derive=function(b){assert.string(b,"type");var a,c,d;if(this.type==="ed25519"&&b==="curve25519"){if(nacl===undefined){nacl=require("tweetnacl")}a=this.part.k.data;if(a[0]===0){a=a.slice(1)}d=nacl.box.keyPair.fromSecretKey(new Uint8Array(a));c=new Buffer(d.publicKey);return(new PrivateKey({type:"curve25519",parts:[{name:"A",data:utils.mpNormalize(c)},{name:"k",data:utils.mpNormalize(a)}]}))}else{if(this.type==="curve25519"&&b==="ed25519"){if(nacl===undefined){nacl=require("tweetnacl")}a=this.part.k.data;if(a[0]===0){a=a.slice(1)}d=nacl.sign.keyPair.fromSeed(new Uint8Array(a));c=new Buffer(d.publicKey);return(new PrivateKey({type:"ed25519",parts:[{name:"A",data:utils.mpNormalize(c)},{name:"k",data:utils.mpNormalize(a)}]}))}}throw (new Error("Key derivation not supported from "+this.type+" to "+b))};PrivateKey.prototype.createVerify=function(a){return(this.toPublic().createVerify(a))};PrivateKey.prototype.createSign=function(i){if(i===undefined){i=this.defaultHashAlgorithm()}assert.string(i,"hash algorithm");if(this.type==="ed25519"&&edCompat!==undefined){return(new edCompat.Signer(this,i))}if(this.type==="curve25519"){throw (new Error("Curve25519 keys are not suitable for signing or verification"))}var g,h,b;try{h=i.toUpperCase();g=crypto.createSign(h)}catch(c){b=c}if(g===undefined||(b instanceof Error&&b.message.match(/Unknown message digest/))){h="RSA-";h+=i.toUpperCase();g=crypto.createSign(h)}assert.ok(g,"failed to create verifier");var a=g.sign.bind(g);var f=this.toBuffer("pkcs1");var d=this.type;var j=this.curve;g.sign=function(){var k=a(f);if(typeof(k)==="string"){k=new Buffer(k,"binary")}k=Signature.parse(k,d,"asn1");k.hashAlgorithm=i;k.curve=j;return(k)};return(g)};PrivateKey.parse=function(d,a,c){if(typeof(d)!=="string"){assert.buffer(d,"data")}if(a===undefined){a="auto"}assert.string(a,"format");if(typeof(c)==="string"){c={filename:c}}assert.optionalObject(c,"options");if(c===undefined){c={}}assert.optionalString(c.filename,"options.filename");if(c.filename===undefined){c.filename="(unnamed)"}assert.object(formats[a],"formats[format]");try{var b=formats[a].read(d,c);assert.ok(b instanceof PrivateKey,"key is not a private key");if(!b.comment){b.comment=c.filename}return(b)}catch(f){if(f.name==="KeyEncryptedError"){throw (f)}throw (new KeyParseError(c.filename,a,f))}};PrivateKey.isPrivateKey=function(b,a){return(utils.isCompatible(b,PrivateKey,a))};PrivateKey.generate=function(b,a){if(a===undefined){a={}}assert.object(a,"options");switch(b){case"ecdsa":if(a.curve===undefined){a.curve="nistp256"}assert.string(a.curve,"options.curve");return(generateECDSA(a.curve));case"ed25519":return(generateED25519());default:throw (new Error('Key generation not supported with key type "'+b+'"'))}};PrivateKey.prototype._sshpkApiVersion=[1,5];PrivateKey._oldVersionDetect=function(a){assert.func(a.toPublic);assert.func(a.createSign);if(a.derive){return([1,3])}if(a.defaultHashAlgorithm){return([1,2])}if(a.formats.auto){return([1,1])}return([1,0])};