module.exports={read:read,readSSHPrivate:readSSHPrivate,write:write};var assert=require("assert-plus");var asn1=require("asn1");var algs=require("../algs");var utils=require("../utils");var crypto=require("crypto");var Key=require("../key");var PrivateKey=require("../private-key");var pem=require("./pem");var rfc4253=require("./rfc4253");var SSHBuffer=require("../ssh-buffer");var errors=require("../errors");var bcrypt;function read(c,d){return(pem.read(c,d))}var MAGIC="openssh-key-v1";function readSSHPrivate(Z,F,aa){F=new SSHBuffer({buffer:F});var U=F.readCString();assert.strictEqual(U,MAGIC,"bad magic string");var N=F.readString();var ad=F.readString();var D=F.readBuffer();var O=F.readInt();if(O!==1){throw (new Error("OpenSSH-format key file contains multiple keys: this is unsupported."))}var G=F.readBuffer();if(Z==="public"){assert.ok(F.atEnd(),"excess bytes left after key");return(rfc4253.read(G))}var K=F.readBuffer();assert.ok(F.atEnd(),"excess bytes left after key");var V=new SSHBuffer({buffer:D});switch(ad){case"none":if(N!=="none"){throw (new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"'))}break;case"bcrypt":var ac=V.readBuffer();var S=V.readInt();var ab=utils.opensshCipherInfo(N);if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}if(typeof(aa.passphrase)==="string"){aa.passphrase=new Buffer(aa.passphrase,"utf-8")}if(!Buffer.isBuffer(aa.passphrase)){throw (new errors.KeyEncryptedError(aa.filename,"OpenSSH"))}var C=new Uint8Array(aa.passphrase);var Q=new Uint8Array(ac);var H=new Uint8Array(ab.keySize+ab.blockSize);var P=bcrypt.pbkdf(C,C.length,Q,Q.length,H,H.length,S);if(P!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}H=new Buffer(H);var I=H.slice(0,ab.keySize);var Y=H.slice(ab.keySize,ab.keySize+ab.blockSize);var T=crypto.createDecipheriv(ab.opensslName,I,Y);T.setAutoPadding(false);var M,J=[];T.once("error",function(a){if(a.toString().indexOf("bad decrypt")!==-1){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}throw (a)});T.write(K);T.end();while((M=T.read())!==null){J.push(M)}K=Buffer.concat(J);break;default:throw (new Error('OpenSSH-format key uses unknown KDF "'+ad+'"'))}F=new SSHBuffer({buffer:K});var W=F.readInt();var X=F.readInt();if(W!==X){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}var E={};var R=rfc4253.readInternal(E,"private",F.remainder());F.skip(E.consumed);var L=F.readString();R.comment=L;return(R)}function write(N,M){var ab;if(PrivateKey.isPrivateKey(N)){ab=N.toPublic()}else{ab=N}var V="none";var T="none";var ac=new Buffer(0);var P={blockSize:8};var Z;if(M!==undefined){Z=M.passphrase;if(typeof(Z)==="string"){Z=new Buffer(Z,"utf-8")}if(Z!==undefined){assert.buffer(Z,"options.passphrase");assert.optionalString(M.cipher,"options.cipher");V=M.cipher;if(V===undefined){V="aes128-ctr"}P=utils.opensshCipherInfo(V);T="bcrypt"}}var J;if(PrivateKey.isPrivateKey(N)){J=new SSHBuffer({});var ad=crypto.randomBytes(4).readUInt32BE(0);J.writeInt(ad);J.writeInt(ad);J.write(N.toBuffer("rfc4253"));J.writeString(N.comment||"");var R=1;while(J._offset%P.blockSize!==0){J.writeChar(R++)}J=J.toBuffer()}switch(T){case"none":break;case"bcrypt":var Q=crypto.randomBytes(16);var ag=16;var X=new SSHBuffer({});X.writeBuffer(Q);X.writeInt(ag);ac=X.toBuffer();if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}var i=new Uint8Array(Z);var af=new Uint8Array(Q);var o=new Uint8Array(P.keySize+P.blockSize);var O=bcrypt.pbkdf(i,i.length,af,af.length,o,o.length,ag);if(O!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}o=new Buffer(o);var L=o.slice(0,P.keySize);var K=o.slice(P.keySize,P.keySize+P.blockSize);var ah=crypto.createCipheriv(P.opensslName,L,K);ah.setAutoPadding(false);var ae,aa=[];ah.once("error",function(a){throw (a)});ah.write(J);ah.end();while((ae=ah.read())!==null){aa.push(ae)}J=Buffer.concat(aa);break;default:throw (new Error("Unsupported kdf "+T))}var W=new SSHBuffer({});W.writeCString(MAGIC);W.writeString(V);W.writeString(T);W.writeBuffer(ac);W.writeInt(1);W.writeBuffer(ab.toBuffer("rfc4253"));if(J){W.writeBuffer(J)}W=W.toBuffer();var H;if(PrivateKey.isPrivateKey(N)){H="OPENSSH PRIVATE KEY"}else{H="OPENSSH PUBLIC KEY"}var U=W.toString("base64");var n=U.length+(U.length/70)+18+16+H.length*2+10;W=new Buffer(n);var S=0;S+=W.write("-----BEGIN "+H+"-----\n",S);for(var I=0;I<U.length;){var Y=I+70;if(Y>U.length){Y=U.length}S+=W.write(U.slice(I,Y),S);W[S++]=10;I=Y}S+=W.write("-----END "+H+"-----\n",S);return(W.slice(0,S))};