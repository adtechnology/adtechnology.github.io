module.exports=PrivateKey;var assert=require("assert-plus");var algs=require("./algs");var crypto=require("crypto");var Fingerprint=require("./fingerprint");var Signature=require("./signature");var errs=require("./errors");var util=require("util");var utils=require("./utils");var dhe=require("./dhe");var generateECDSA=dhe.generateECDSA;var generateED25519=dhe.generateED25519;var edCompat;var nacl;try{edCompat=require("./ed-compat")}catch(e){}var Key=require("./key");var InvalidAlgorithmError=errs.InvalidAlgorithmError;var KeyParseError=errs.KeyParseError;var KeyEncryptedError=errs.KeyEncryptedError;var formats={};formats.auto=require("./formats/auto");formats.pem=require("./formats/pem");formats.pkcs1=require("./formats/pkcs1");formats.pkcs8=require("./formats/pkcs8");formats.rfc4253=require("./formats/rfc4253");formats["ssh-private"]=require("./formats/ssh-private");formats.openssh=formats["ssh-private"];formats.ssh=formats["ssh-private"];formats.dnssec=require("./formats/dnssec");function PrivateKey(b){assert.object(b,"options");Key.call(this,b);this._pubCache=undefined}util.inherits(PrivateKey,Key);PrivateKey.formats=formats;PrivateKey.prototype.toBuffer=function(c,d){if(c===undefined){c="pkcs1"}assert.string(c,"format");assert.object(formats[c],"formats[format]");assert.optionalObject(d,"options");return(formats[c].write(this,d))};PrivateKey.prototype.hash=function(b){return(this.toPublic().hash(b))};PrivateKey.prototype.toPublic=function(){if(this._pubCache){return(this._pubCache)}var h=algs.info[this.type];var i=[];for(var g=0;g<h.parts.length;++g){var f=h.parts[g];i.push(this.part[f])}this._pubCache=new Key({type:this.type,source:this,parts:i});if(this.comment){this._pubCache.comment=this.comment}return(this._pubCache)};PrivateKey.prototype.derive=function(f){assert.string(f,"type");var g,i,h;if(this.type==="ed25519"&&f==="curve25519"){if(nacl===undefined){nacl=require("tweetnacl")}g=this.part.k.data;if(g[0]===0){g=g.slice(1)}h=nacl.box.keyPair.fromSecretKey(new Uint8Array(g));i=new Buffer(h.publicKey);return(new PrivateKey({type:"curve25519",parts:[{name:"A",data:utils.mpNormalize(i)},{name:"k",data:utils.mpNormalize(g)}]}))}else{if(this.type==="curve25519"&&f==="ed25519"){if(nacl===undefined){nacl=require("tweetnacl")}g=this.part.k.data;if(g[0]===0){g=g.slice(1)}h=nacl.sign.keyPair.fromSeed(new Uint8Array(g));i=new Buffer(h.publicKey);return(new PrivateKey({type:"ed25519",parts:[{name:"A",data:utils.mpNormalize(i)},{name:"k",data:utils.mpNormalize(g)}]}))}}throw (new Error("Key derivation not supported from "+this.type+" to "+f))};PrivateKey.prototype.createVerify=function(b){return(this.toPublic().createVerify(b))};PrivateKey.prototype.createSign=function(s){if(s===undefined){s=this.defaultHashAlgorithm()}assert.string(s,"hash algorithm");if(this.type==="ed25519"&&edCompat!==undefined){return(new edCompat.Signer(this,s))}if(this.type==="curve25519"){throw (new Error("Curve25519 keys are not suitable for signing or verification"))}var l,k,p;try{k=s.toUpperCase();l=crypto.createSign(k)}catch(o){p=o}if(l===undefined||(p instanceof Error&&p.message.match(/Unknown message digest/))){k="RSA-";k+=s.toUpperCase();l=crypto.createSign(k)}assert.ok(l,"failed to create verifier");var q=l.sign.bind(l);var m=this.toBuffer("pkcs1");var n=this.type;var r=this.curve;l.sign=function(){var a=q(m);if(typeof(a)==="string"){a=new Buffer(a,"binary")}a=Signature.parse(a,n,"asn1");a.hashAlgorithm=s;a.curve=r;return(a)};return(l)};PrivateKey.parse=function(k,i,g){if(typeof(k)!=="string"){assert.buffer(k,"data")}if(i===undefined){i="auto"}assert.string(i,"format");if(typeof(g)==="string"){g={filename:g}}assert.optionalObject(g,"options");if(g===undefined){g={}}assert.optionalString(g.filename,"options.filename");if(g.filename===undefined){g.filename="(unnamed)"}assert.object(formats[i],"formats[format]");try{var h=formats[i].read(k,g);assert.ok(h instanceof PrivateKey,"key is not a private key");if(!h.comment){h.comment=g.filename}return(h)}catch(j){if(j.name==="KeyEncryptedError"){throw (j)}throw (new KeyParseError(g.filename,i,j))}};PrivateKey.isPrivateKey=function(c,d){return(utils.isCompatible(c,PrivateKey,d))};PrivateKey.generate=function(c,d){if(d===undefined){d={}}assert.object(d,"options");switch(c){case"ecdsa":if(d.curve===undefined){d.curve="nistp256"}assert.string(d.curve,"options.curve");return(generateECDSA(d.curve));case"ed25519":return(generateED25519());default:throw (new Error('Key generation not supported with key type "'+c+'"'))}};PrivateKey.prototype._sshpkApiVersion=[1,5];PrivateKey._oldVersionDetect=function(b){assert.func(b.toPublic);assert.func(b.createSign);if(b.derive){return([1,3])}if(b.defaultHashAlgorithm){return([1,2])}if(b.formats.auto){return([1,1])}return([1,0])};