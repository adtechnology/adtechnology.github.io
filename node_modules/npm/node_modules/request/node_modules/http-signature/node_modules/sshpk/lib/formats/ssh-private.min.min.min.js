module.exports={read:read,readSSHPrivate:readSSHPrivate,write:write};var assert=require("assert-plus");var asn1=require("asn1");var algs=require("../algs");var utils=require("../utils");var crypto=require("crypto");var Key=require("../key");var PrivateKey=require("../private-key");var pem=require("./pem");var rfc4253=require("./rfc4253");var SSHBuffer=require("../ssh-buffer");var errors=require("../errors");var bcrypt;function read(b,a){return(pem.read(b,a))}var MAGIC="openssh-key-v1";function readSSHPrivate(e,w,d){w=new SSHBuffer({buffer:w});var j=w.readCString();assert.strictEqual(j,MAGIC,"bad magic string");var A=w.readString();var a=w.readString();var y=w.readBuffer();var p=w.readInt();if(p!==1){throw (new Error("OpenSSH-format key file contains multiple keys: this is unsupported."))}var v=w.readBuffer();if(e==="public"){assert.ok(w.atEnd(),"excess bytes left after key");return(rfc4253.read(v))}var r=w.readBuffer();assert.ok(w.atEnd(),"excess bytes left after key");var i=new SSHBuffer({buffer:y});switch(a){case"none":if(A!=="none"){throw (new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"'))}break;case"bcrypt":var b=i.readBuffer();var l=i.readInt();var c=utils.opensshCipherInfo(A);if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}if(typeof(d.passphrase)==="string"){d.passphrase=new Buffer(d.passphrase,"utf-8")}if(!Buffer.isBuffer(d.passphrase)){throw (new errors.KeyEncryptedError(d.filename,"OpenSSH"))}var z=new Uint8Array(d.passphrase);var n=new Uint8Array(b);var u=new Uint8Array(c.keySize+c.blockSize);var o=bcrypt.pbkdf(z,z.length,n,n.length,u,u.length,l);if(o!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}u=new Buffer(u);var t=u.slice(0,c.keySize);var f=u.slice(c.keySize,c.keySize+c.blockSize);var k=crypto.createDecipheriv(c.opensslName,t,f);k.setAutoPadding(false);var q,s=[];k.once("error",function(C){if(C.toString().indexOf("bad decrypt")!==-1){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}throw (C)});k.write(r);k.end();while((q=k.read())!==null){s.push(q)}r=Buffer.concat(s);break;default:throw (new Error('OpenSSH-format key uses unknown KDF "'+a+'"'))}w=new SSHBuffer({buffer:r});var h=w.readInt();var g=w.readInt();if(h!==g){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}var x={};var m=rfc4253.readInternal(x,"private",w.remainder());w.skip(x.consumed);var B=w.readString();m.comment=B;return(m)}function write(t,E){var g;if(PrivateKey.isPrivateKey(t)){g=t.toPublic()}else{g=t}var A="none";var B="none";var f=new Buffer(0);var D={blockSize:8};var j;if(E!==undefined){j=E.passphrase;if(typeof(j)==="string"){j=new Buffer(j,"utf-8")}if(j!==undefined){assert.buffer(j,"options.passphrase");assert.optionalString(E.cipher,"options.cipher");A=E.cipher;if(A===undefined){A="aes128-ctr"}D=utils.opensshCipherInfo(A);B="bcrypt"}}var G;if(PrivateKey.isPrivateKey(t)){G=new SSHBuffer({});var e=crypto.randomBytes(4).readUInt32BE(0);G.writeInt(e);G.writeInt(e);G.write(t.toBuffer("rfc4253"));G.writeString(t.comment||"");var r=1;while(G._offset%D.blockSize!==0){G.writeChar(r++)}G=G.toBuffer()}switch(B){case"none":break;case"bcrypt":var C=crypto.randomBytes(16);var b=16;var l=new SSHBuffer({});l.writeBuffer(C);l.writeInt(b);f=l.toBuffer();if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}var z=new Uint8Array(j);var c=new Uint8Array(C);var x=new Uint8Array(D.keySize+D.blockSize);var s=bcrypt.pbkdf(z,z.length,c,c.length,x,x.length,b);if(s!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}x=new Buffer(x);var u=x.slice(0,D.keySize);var F=x.slice(D.keySize,D.keySize+D.blockSize);var a=crypto.createCipheriv(D.opensslName,u,F);a.setAutoPadding(false);var d,h=[];a.once("error",function(i){throw (i)});a.write(G);a.end();while((d=a.read())!==null){h.push(d)}G=Buffer.concat(h);break;default:throw (new Error("Unsupported kdf "+B))}var m=new SSHBuffer({});m.writeCString(MAGIC);m.writeString(A);m.writeString(B);m.writeBuffer(f);m.writeInt(1);m.writeBuffer(g.toBuffer("rfc4253"));if(G){m.writeBuffer(G)}m=m.toBuffer();var w;if(PrivateKey.isPrivateKey(t)){w="OPENSSH PRIVATE KEY"}else{w="OPENSSH PUBLIC KEY"}var p=m.toString("base64");var y=p.length+(p.length/70)+18+16+w.length*2+10;m=new Buffer(y);var q=0;q+=m.write("-----BEGIN "+w+"-----\n",q);for(var v=0;v<p.length;){var k=v+70;if(k>p.length){k=p.length}q+=m.write(p.slice(v,k),q);m[q++]=10;v=k}q+=m.write("-----END "+w+"-----\n",q);return(m.slice(0,q))};