module.exports={read:read,readSSHPrivate:readSSHPrivate,write:write};var assert=require("assert-plus");var asn1=require("asn1");var algs=require("../algs");var utils=require("../utils");var crypto=require("crypto");var Key=require("../key");var PrivateKey=require("../private-key");var pem=require("./pem");var rfc4253=require("./rfc4253");var SSHBuffer=require("../ssh-buffer");var errors=require("../errors");var bcrypt;function read(b,a){return(pem.read(b,a))}var MAGIC="openssh-key-v1";function readSSHPrivate(i,y,h){y=new SSHBuffer({buffer:y});var n=y.readCString();assert.strictEqual(n,MAGIC,"bad magic string");var c=y.readString();var e=y.readString();var a=y.readBuffer();var r=y.readInt();if(r!==1){throw (new Error("OpenSSH-format key file contains multiple keys: this is unsupported."))}var x=y.readBuffer();if(i==="public"){assert.ok(y.atEnd(),"excess bytes left after key");return(rfc4253.read(x))}var t=y.readBuffer();assert.ok(y.atEnd(),"excess bytes left after key");var m=new SSHBuffer({buffer:a});switch(e){case"none":if(c!=="none"){throw (new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"'))}break;case"bcrypt":var f=m.readBuffer();var p=m.readInt();var g=utils.opensshCipherInfo(c);if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}if(typeof(h.passphrase)==="string"){h.passphrase=new Buffer(h.passphrase,"utf-8")}if(!Buffer.isBuffer(h.passphrase)){throw (new errors.KeyEncryptedError(h.filename,"OpenSSH"))}var b=new Uint8Array(h.passphrase);var q=new Uint8Array(f);var w=new Uint8Array(g.keySize+g.blockSize);var B=bcrypt.pbkdf(b,b.length,q,q.length,w,w.length,p);if(B!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}w=new Buffer(w);var v=w.slice(0,g.keySize);var j=w.slice(g.keySize,g.keySize+g.blockSize);var o=crypto.createDecipheriv(g.opensslName,v,j);o.setAutoPadding(false);var s,u=[];o.once("error",function(C){if(C.toString().indexOf("bad decrypt")!==-1){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}throw (C)});o.write(t);o.end();while((s=o.read())!==null){u.push(s)}t=Buffer.concat(u);break;default:throw (new Error('OpenSSH-format key uses unknown KDF "'+e+'"'))}y=new SSHBuffer({buffer:t});var l=y.readInt();var k=y.readInt();if(l!==k){throw (new Error("Incorrect passphrase supplied, could not decrypt key"))}var z={};var A=rfc4253.readInternal(z,"private",y.remainder());y.skip(z.consumed);var d=y.readString();A.comment=d;return(A)}function write(G,f){var B;if(PrivateKey.isPrivateKey(G)){B=G.toPublic()}else{B=G}var b="none";var c="none";var A=new Buffer(0);var e={blockSize:8};var r;if(f!==undefined){r=f.passphrase;if(typeof(r)==="string"){r=new Buffer(r,"utf-8")}if(r!==undefined){assert.buffer(r,"options.passphrase");assert.optionalString(f.cipher,"options.cipher");b=f.cipher;if(b===undefined){b="aes128-ctr"}e=utils.opensshCipherInfo(b);c="bcrypt"}}var h;if(PrivateKey.isPrivateKey(G)){h=new SSHBuffer({});var p=crypto.randomBytes(4).readUInt32BE(0);h.writeInt(p);h.writeInt(p);h.write(G.toBuffer("rfc4253"));h.writeString(G.comment||"");var u=1;while(h._offset%e.blockSize!==0){h.writeChar(u++)}h=h.toBuffer()}switch(c){case"none":break;case"bcrypt":var d=crypto.randomBytes(16);var k=16;var s=new SSHBuffer({});s.writeBuffer(d);s.writeInt(k);A=s.toBuffer();if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}var a=new Uint8Array(r);var l=new Uint8Array(d);var y=new Uint8Array(e.keySize+e.blockSize);var F=bcrypt.pbkdf(a,a.length,l,l.length,y,y.length,k);if(F!==0){throw (new Error("bcrypt_pbkdf function returned failure, parameters invalid"))}y=new Buffer(y);var v=y.slice(0,e.keySize);var g=y.slice(e.keySize,e.keySize+e.blockSize);var j=crypto.createCipheriv(e.opensslName,v,g);j.setAutoPadding(false);var m,q=[];j.once("error",function(i){throw (i)});j.write(h);j.end();while((m=j.read())!==null){q.push(m)}h=Buffer.concat(q);break;default:throw (new Error("Unsupported kdf "+c))}var D=new SSHBuffer({});D.writeCString(MAGIC);D.writeString(b);D.writeString(c);D.writeBuffer(A);D.writeInt(1);D.writeBuffer(B.toBuffer("rfc4253"));if(h){D.writeBuffer(h)}D=D.toBuffer();var x;if(PrivateKey.isPrivateKey(G)){x="OPENSSH PRIVATE KEY"}else{x="OPENSSH PUBLIC KEY"}var E=D.toString("base64");var z=E.length+(E.length/70)+18+16+x.length*2+10;D=new Buffer(z);var t=0;t+=D.write("-----BEGIN "+x+"-----\n",t);for(var w=0;w<E.length;){var C=w+70;if(C>E.length){C=E.length}t+=D.write(E.slice(w,C),t);D[t++]=10;w=C}t+=D.write("-----END "+x+"-----\n",t);return(D.slice(0,t))};