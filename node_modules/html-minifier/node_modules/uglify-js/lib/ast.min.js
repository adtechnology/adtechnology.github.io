"use strict";function DEFNODE(g,h,c,a){if(arguments.length<4){a=AST_Node}if(!h){h=[]}else{h=h.split(/\s+/)}var f=h;if(a&&a.PROPS){h=h.concat(a.PROPS)}var b="return function AST_"+g+"(props){ if (props) { ";for(var d=h.length;--d>=0;){b+="this."+h[d]+" = props."+h[d]+";"}var e=a&&new a;if(e&&e.initialize||(c&&c.initialize)){b+="this.initialize();"}b+="}}";var j=new Function(b)();if(e){j.prototype=e;j.BASE=a}if(a){a.SUBCLASSES.push(j)}j.prototype.CTOR=j;j.PROPS=h||null;j.SELF_PROPS=f;j.SUBCLASSES=[];if(g){j.prototype.TYPE=j.TYPE=g}if(c){for(d in c){if(HOP(c,d)){if(/^\$/.test(d)){j[d.substr(1)]=c[d]}else{j.prototype[d]=c[d]}}}}j.DEFMETHOD=function(i,k){this.prototype[i]=k};if(typeof exports!=="undefined"){exports["AST_"+g]=j}return j}var AST_Token=DEFNODE("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw",{},null);var AST_Node=DEFNODE("Node","start end",{_clone:function(a){if(a){var b=this.clone();return b.transform(new TreeTransformer(function(c){if(c!==b){return c.clone(true)}}))}return new this.CTOR(this)},clone:function(a){return this._clone(a)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(a){return a._visit(this)},walk:function(a){return this._walk(a)}},null);AST_Node.warn_function=null;AST_Node.warn=function(a,b){if(AST_Node.warn_function){AST_Node.warn_function(string_template(a,b))}};var AST_Statement=DEFNODE("Statement",null,{$documentation:"Base class of all statements"});var AST_Debugger=DEFNODE("Debugger",null,{$documentation:"Represents a debugger statement"},AST_Statement);var AST_Directive=DEFNODE("Directive","value quote",{$documentation:'Represents a directive, like "use strict";',$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",quote:"[string] the original quote character"}},AST_Statement);var AST_SimpleStatement=DEFNODE("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(a){return a._visit(this,function(){this.body._walk(a)})}},AST_Statement);function walk_body(d,e){var b=d.body;if(b instanceof AST_Statement){b._walk(e)}else{for(var c=0,a=b.length;c<a;c++){b[c]._walk(e)}}}var AST_Block=DEFNODE("Block","body",{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements"},_walk:function(a){return a._visit(this,function(){walk_body(this,a)})}},AST_Statement);var AST_BlockStatement=DEFNODE("BlockStatement",null,{$documentation:"A block statement"},AST_Block);var AST_EmptyStatement=DEFNODE("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)"},AST_Statement);var AST_StatementWithBody=DEFNODE("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"}},AST_Statement);var AST_LabeledStatement=DEFNODE("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(a){return a._visit(this,function(){this.label._walk(a);this.body._walk(a)})},clone:function(a){var c=this._clone(a);if(a){var b=c.label;var d=this.label;c.walk(new TreeWalker(function(e){if(e instanceof AST_LoopControl&&e.label&&e.label.thedef===d){e.label.thedef=b;b.references.push(e)}}))}return c}},AST_StatementWithBody);var AST_IterationStatement=DEFNODE("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it."},AST_StatementWithBody);var AST_DWLoop=DEFNODE("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"}},AST_IterationStatement);var AST_Do=DEFNODE("Do",null,{$documentation:"A `do` statement",_walk:function(a){return a._visit(this,function(){this.body._walk(a);this.condition._walk(a)})}},AST_DWLoop);var AST_While=DEFNODE("While",null,{$documentation:"A `while` statement",_walk:function(a){return a._visit(this,function(){this.condition._walk(a);this.body._walk(a)})}},AST_DWLoop);var AST_For=DEFNODE("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_walk:function(a){return a._visit(this,function(){if(this.init){this.init._walk(a)}if(this.condition){this.condition._walk(a)}if(this.step){this.step._walk(a)}this.body._walk(a)})}},AST_IterationStatement);var AST_ForIn=DEFNODE("ForIn","init object",{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",object:"[AST_Node] the object that we're looping through"},_walk:function(a){return a._visit(this,function(){this.init._walk(a);this.object._walk(a);this.body._walk(a)})}},AST_IterationStatement);var AST_With=DEFNODE("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(a){return a._visit(this,function(){this.expression._walk(a);this.body._walk(a)})}},AST_StatementWithBody);var AST_Scope=DEFNODE("Scope","variables functions uses_with uses_eval parent_scope enclosed cname",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{variables:"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",functions:"[Object/S] like `variables`, but only lists function declarations",uses_with:"[boolean/S] tells whether this scope uses the `with` statement",uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",cname:"[integer/S] current index for mangling variables (used internally by the mangler)"},clone:function(a){var b=this._clone(a);if(this.variables){b.variables=this.variables.clone()}if(this.functions){b.functions=this.functions.clone()}if(this.enclosed){b.enclosed=this.enclosed.slice()}return b},pinned:function(){return this.uses_eval||this.uses_with}},AST_Block);var AST_Toplevel=DEFNODE("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Object/S] a map of name -> SymbolDef for all undeclared names"},wrap_commonjs:function(b){var a=this.body;var d="(function(exports){'$ORIG';})(typeof "+b+"=='undefined'?("+b+"={}):"+b+");";d=parse(d);d=d.transform(new TreeTransformer(function c(e){if(e instanceof AST_Directive&&e.value=="$ORIG"){return MAP.splice(a)}}));return d}},AST_Scope);var AST_Lambda=DEFNODE("Lambda","name argnames uses_arguments",{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function",argnames:"[AST_SymbolFunarg*] array of function arguments",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array"},_walk:function(a){return a._visit(this,function(){if(this.name){this.name._walk(a)}var d=this.argnames;for(var c=0,b=d.length;c<b;c++){d[c]._walk(a)}walk_body(this,a)})}},AST_Scope);var AST_Accessor=DEFNODE("Accessor",null,{$documentation:"A setter/getter function.  The `name` property is always null."},AST_Lambda);var AST_Function=DEFNODE("Function","inlined",{$documentation:"A function expression"},AST_Lambda);var AST_Defun=DEFNODE("Defun","inlined",{$documentation:"A function definition"},AST_Lambda);var AST_Jump=DEFNODE("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"},AST_Statement);var AST_Exit=DEFNODE("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(a){return a._visit(this,this.value&&function(){this.value._walk(a)})}},AST_Jump);var AST_Return=DEFNODE("Return",null,{$documentation:"A `return` statement"},AST_Exit);var AST_Throw=DEFNODE("Throw",null,{$documentation:"A `throw` statement"},AST_Exit);var AST_LoopControl=DEFNODE("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(a){return a._visit(this,this.label&&function(){this.label._walk(a)})}},AST_Jump);var AST_Break=DEFNODE("Break",null,{$documentation:"A `break` statement"},AST_LoopControl);var AST_Continue=DEFNODE("Continue",null,{$documentation:"A `continue` statement"},AST_LoopControl);var AST_If=DEFNODE("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(a){return a._visit(this,function(){this.condition._walk(a);this.body._walk(a);if(this.alternative){this.alternative._walk(a)}})}},AST_StatementWithBody);var AST_Switch=DEFNODE("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_walk:function(a){return a._visit(this,function(){this.expression._walk(a);walk_body(this,a)})}},AST_Block);var AST_SwitchBranch=DEFNODE("SwitchBranch",null,{$documentation:"Base class for `switch` branches"},AST_Block);var AST_Default=DEFNODE("Default",null,{$documentation:"A `default` switch branch"},AST_SwitchBranch);var AST_Case=DEFNODE("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(a){return a._visit(this,function(){this.expression._walk(a);walk_body(this,a)})}},AST_SwitchBranch);var AST_Try=DEFNODE("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(a){return a._visit(this,function(){walk_body(this,a);if(this.bcatch){this.bcatch._walk(a)}if(this.bfinally){this.bfinally._walk(a)}})}},AST_Block);var AST_Catch=DEFNODE("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[AST_SymbolCatch] symbol for the exception"},_walk:function(a){return a._visit(this,function(){this.argname._walk(a);walk_body(this,a)})}},AST_Block);var AST_Finally=DEFNODE("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},AST_Block);var AST_Definitions=DEFNODE("Definitions","definitions",{$documentation:"Base class for `var` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_walk:function(a){return a._visit(this,function(){var d=this.definitions;for(var c=0,b=d.length;c<b;c++){d[c]._walk(a)}})}},AST_Statement);var AST_Var=DEFNODE("Var",null,{$documentation:"A `var` statement"},AST_Definitions);var AST_VarDef=DEFNODE("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_walk:function(a){return a._visit(this,function(){this.name._walk(a);if(this.value){this.value._walk(a)}})}});var AST_Call=DEFNODE("Call","expression args",{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function",args:"[AST_Node*] array of arguments"},_walk:function(a){return a._visit(this,function(){this.expression._walk(a);this.args.forEach(function(b){b._walk(a)})})}});var AST_New=DEFNODE("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties"},AST_Call);var AST_Sequence=DEFNODE("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_walk:function(a){return a._visit(this,function(){this.expressions.forEach(function(b){b._walk(a)})})}});var AST_PropAccess=DEFNODE("PropAccess","expression property",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"}});var AST_Dot=DEFNODE("Dot",null,{$documentation:"A dotted property access expression",_walk:function(a){return a._visit(this,function(){this.expression._walk(a)})}},AST_PropAccess);var AST_Sub=DEFNODE("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',_walk:function(a){return a._visit(this,function(){this.expression._walk(a);this.property._walk(a)})}},AST_PropAccess);var AST_Unary=DEFNODE("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(a){return a._visit(this,function(){this.expression._walk(a)})}});var AST_UnaryPrefix=DEFNODE("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},AST_Unary);var AST_UnaryPostfix=DEFNODE("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},AST_Unary);var AST_Binary=DEFNODE("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(a){return a._visit(this,function(){this.left._walk(a);this.right._walk(a)})}});var AST_Conditional=DEFNODE("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(a){return a._visit(this,function(){this.condition._walk(a);this.consequent._walk(a);this.alternative._walk(a)})}});var AST_Assign=DEFNODE("Assign",null,{$documentation:"An assignment expression — `a = b + 5`"},AST_Binary);var AST_Array=DEFNODE("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(a){return a._visit(this,function(){var d=this.elements;for(var c=0,b=d.length;c<b;c++){d[c]._walk(a)}})}});var AST_Object=DEFNODE("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(a){return a._visit(this,function(){var d=this.properties;for(var c=0,b=d.length;c<b;c++){d[c]._walk(a)}})}});var AST_ObjectProperty=DEFNODE("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_SymbolAccessor] property name. For ObjectKeyVal this is a string. For getters and setters this is an AST_SymbolAccessor.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_walk:function(a){return a._visit(this,function(){this.value._walk(a)})}});var AST_ObjectKeyVal=DEFNODE("ObjectKeyVal","quote",{$documentation:"A key: value object property",$propdoc:{quote:"[string] the original quote character"}},AST_ObjectProperty);var AST_ObjectSetter=DEFNODE("ObjectSetter",null,{$documentation:"An object setter property"},AST_ObjectProperty);var AST_ObjectGetter=DEFNODE("ObjectGetter",null,{$documentation:"An object getter property"},AST_ObjectProperty);var AST_Symbol=DEFNODE("Symbol","scope name thedef",{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"});var AST_SymbolAccessor=DEFNODE("SymbolAccessor",null,{$documentation:"The name of a property accessor (setter/getter function)"},AST_Symbol);var AST_SymbolDeclaration=DEFNODE("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var, function name or argument, symbol in catch)"},AST_Symbol);var AST_SymbolVar=DEFNODE("SymbolVar",null,{$documentation:"Symbol defining a variable"},AST_SymbolDeclaration);var AST_SymbolFunarg=DEFNODE("SymbolFunarg",null,{$documentation:"Symbol naming a function argument"},AST_SymbolVar);var AST_SymbolDefun=DEFNODE("SymbolDefun",null,{$documentation:"Symbol defining a function"},AST_SymbolDeclaration);var AST_SymbolLambda=DEFNODE("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},AST_SymbolDeclaration);var AST_SymbolCatch=DEFNODE("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},AST_SymbolDeclaration);var AST_Label=DEFNODE("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[];this.thedef=this}},AST_Symbol);var AST_SymbolRef=DEFNODE("SymbolRef",null,{$documentation:"Reference to some symbol (not definition/declaration)"},AST_Symbol);var AST_LabelRef=DEFNODE("LabelRef",null,{$documentation:"Reference to a label symbol"},AST_Symbol);var AST_This=DEFNODE("This",null,{$documentation:"The `this` symbol"},AST_Symbol);var AST_Constant=DEFNODE("Constant",null,{$documentation:"Base class for all constants",getValue:function(){return this.value}});var AST_String=DEFNODE("String","value quote",{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",quote:"[string] the original quote character"}},AST_Constant);var AST_Number=DEFNODE("Number","value literal",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value",literal:"[string] numeric value as string (optional)"}},AST_Constant);var AST_RegExp=DEFNODE("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"}},AST_Constant);var AST_Atom=DEFNODE("Atom",null,{$documentation:"Base class for atoms"},AST_Constant);var AST_Null=DEFNODE("Null",null,{$documentation:"The `null` atom",value:null},AST_Atom);var AST_NaN=DEFNODE("NaN",null,{$documentation:"The impossible value",value:0/0},AST_Atom);var AST_Undefined=DEFNODE("Undefined",null,{$documentation:"The `undefined` value",value:(function(){}())},AST_Atom);var AST_Hole=DEFNODE("Hole",null,{$documentation:"A hole in an array",value:(function(){}())},AST_Atom);var AST_Infinity=DEFNODE("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},AST_Atom);var AST_Boolean=DEFNODE("Boolean",null,{$documentation:"Base class for booleans"},AST_Atom);var AST_False=DEFNODE("False",null,{$documentation:"The `false` atom",value:false},AST_Boolean);var AST_True=DEFNODE("True",null,{$documentation:"The `true` atom",value:true},AST_Boolean);function TreeWalker(a){this.visit=a;this.stack=[];this.directives=Object.create(null)}TreeWalker.prototype={_visit:function(c,b){this.push(c);var a=this.visit(c,b?function(){b.call(c)}:noop);if(!a&&b){b.call(c)}this.pop();return a},parent:function(a){return this.stack[this.stack.length-2-(a||0)]},push:function(a){if(a instanceof AST_Lambda){this.directives=Object.create(this.directives)}else{if(a instanceof AST_Directive&&!this.directives[a.value]){this.directives[a.value]=a}}this.stack.push(a)},pop:function(){if(this.stack.pop() instanceof AST_Lambda){this.directives=Object.getPrototypeOf(this.directives)}},self:function(){return this.stack[this.stack.length-1]},find_parent:function(d){var b=this.stack;for(var c=b.length;--c>=0;){var a=b[c];if(a instanceof d){return a}}},has_directive:function(d){var b=this.directives[d];if(b){return b}var e=this.stack[this.stack.length-1];if(e instanceof AST_Scope){for(var c=0;c<e.body.length;++c){var a=e.body[c];if(!(a instanceof AST_Directive)){break}if(a.value==d){return a}}}},loopcontrol_target:function(d){var b=this.stack;if(d.label){for(var c=b.length;--c>=0;){var a=b[c];if(a instanceof AST_LabeledStatement&&a.label.name==d.label.name){return a.body}}}else{for(var c=b.length;--c>=0;){var a=b[c];if(a instanceof AST_IterationStatement||d instanceof AST_Break&&a instanceof AST_Switch){return a}}}},in_boolean_context:function(){var a=this.self();for(var b=0,c;c=this.parent(b);b++){if(c instanceof AST_SimpleStatement||c instanceof AST_Conditional&&c.condition===a||c instanceof AST_DWLoop&&c.condition===a||c instanceof AST_For&&c.condition===a||c instanceof AST_If&&c.condition===a||c instanceof AST_UnaryPrefix&&c.operator=="!"&&c.expression===a){return true}if(c instanceof AST_Binary&&(c.operator=="&&"||c.operator=="||")||c instanceof AST_Conditional||c.tail_node()===a){a=c}else{return false}}}};